/**
 * RQDQL.com, Requirements Definition and Query Language
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are PROHIBITED without prior written 
 * permission from the author. This product may NOT be used 
 * anywhere and on any computer except the server platform of 
 * rqdql.com. located at www.rqdql.com. If you received this 
 * code occasionally and without intent to use it, please report 
 * this incident to the author by email: team@rqdql.com
 *
 * @author Yegor Bugayenko <egor@tpc2.com>
 * @copyright Copyright (c) rqdql.com, 2010
 * @version $Id$
 */

#include <string>
#include <vector>
#include <boost/format.hpp>
#include <boost/algorithm/string/join.hpp>
#include <boost/regex.hpp>
#include <boost/scope_exit.hpp>
#include "Solm/Term.h"
#include "rqdql.h"
#include "rqdql/Exception.h"

using std::string;

/**
 * These files are auto-generated by FLEX/BISON tools called from
 * Makefile. Without these files we can't proceed here
 * and compilation will be failed.
 */
#include "Solm/Term/lisp.y.c-symbols.h"

/**
 * Declaration here, implementation later
 */
void termerror(const char*, ...);

/**
 * Global variable, to be used as a target for BISON parser
 *
 * This approach is NOT thread-safe, but good enough for now
 */
solm::Term::Term* term_target;

/**
 * These files are auto-generated by FLEX/BISON tools called from
 * Makefile. Without these files we can't proceed here
 * and compilation will be failed.
 */
#include "Solm/Term/lisp.l.c"
#include "Solm/Term/lisp.y.c"

solm::Term::Term(const string& s) : _terms() {
    /**
     * If nothing provided we assume that it's a simple term TRUE
     * and we should skip all syntax analysis and processing.
     */
    if (s.empty()) {
        _value = "true";
        return;
    }
    
    /**
     * We can't start this function if the same function is already
     * running. If we do this, we will break the BISON parser.
     */
    if (term_target) {
        throw rqdql::Exception(
            rqdql::_t("You can't start Term() from itself")
        );
    }
    
    /**
     * This variable is used by the parser.
     */
    term_target = this;

    /**
     * Drop this link to NULL once the execution is finished. We should
     * execute this procedure in any case, no matter whether we finish this
     * function with success or exception.
     */
    BOOST_SCOPE_EXIT( (&term_target) ) {
        term_target = 0;
    } BOOST_SCOPE_EXIT_END
        
    try {
        term_switch_to_buffer(term_scan_string(s.c_str()));
        termparse();
    } catch (string ex) {
        /**
         * This exception will be thrown by termerror(), see
         * the end of this file. termparse() calls this termerror()
         * function when it finds some problem in parsing.
         */
        throw rqdql::Exception(
            boost::format(rqdql::_t("Invalid TERM '%s' (%s)")) % s % ex
        );
    }
}

bool solm::Term::operator==(const solm::Term& t) const {
    if (_value != t._value) {
        return false;
    }
    if (_terms.size() != t._terms.size()) {
        return true;
    }
    return equal(_terms.begin(), _terms.end(), t._terms.begin());
}

bool solm::Term::is(solm::Term::Kind k) const {
    switch (k) {
        case T_RULE:
            return variables().size();
        case T_FACT:
            return is(T_OBJECT) && _terms.size() && !variables().size();
        case T_ATOM:
            return (is(T_OBJECT) || is(T_VARIABLE) || is(T_NUMBER) || is(T_TEXT)) && !_terms.size();
        case T_NUMBER:
            return boost::regex_match(_value, boost::regex("[\\-\\+]?[0-9]+(\\.[0-9]+)?"));
        case T_TEXT:
            return boost::regex_match(_value, boost::regex("'.*'"));
        case T_OBJECT:
            return boost::regex_match(_value, boost::regex("[a-z_][a-zA-Z0-9_]*"));
        case T_VARIABLE:
            return boost::regex_match(_value, boost::regex("[A-Z][a-zA-Z0-9_]*"));
        case T_FALSE:
            return _value == "false";
        case T_TRUE:
            return _value == "true";
        case T_CONJUNCTOR:
            return _value == ",";
        case T_OPERATOR:
            return boost::regex_match(_value, boost::regex("[,:/\\\\\\*\\-\\?\\+\\$\\&<>=]+|is"));
        default:
            return false;
    }
}

solm::Term::operator string() const {
    std::vector<string> v;
    for (std::vector<Term>::const_iterator i = _terms.begin(); i != _terms.end(); ++i) {
        v.push_back((string)(*i));
    }

    string s;
    if (is(T_OPERATOR)) {
        s = boost::algorithm::join(v, (is(T_CONJUNCTOR) ? "" : " ") + _value + " ");
    } else {
        s = _value;
        if (v.size()) {
            s += "(" + boost::algorithm::join(v, ", ") + ")";
        }
    }
    return s;
}

solm::Term::operator bool() const {
    if (is(T_FALSE)) {
        return false;
    }
    for (Terms::const_iterator i = _terms.begin(); i != _terms.end(); ++i) {
        if (!(*i)) {
            return false;
        }
    }
    return true;
}

const solm::Term::Terms solm::Term::variables() const {
    Terms v;
    if (is(T_VARIABLE)) {
        v.push_back(*this);
    } else {
        for (Terms::const_iterator i = _terms.begin(); i != _terms.end(); ++i) {
            Terms subs = (*i).variables();
            for (Terms::const_iterator j = subs.begin(); j != subs.end(); ++j) {
                v.push_back(*j);
            }
        }
    }
    return v;
}

const solm::Term solm::Term::operator/(const solm::Term& t) {
    /**
     * This implementation is very primitive as it is now. It resolves
     * only very basic and simple queries. We should replace it with 
     * proper integratio with PROLOG.
     */
     
    std::vector<string> v;

    /**
     * This is a conjunctor of other terms.
     */
    if (is(T_CONJUNCTOR)) {
        for (Terms::const_iterator i = _terms.begin(); i != _terms.end(); ++i) {
            Term sub = (Term)(*i) / t;
            if (sub) {
                v.push_back((string)sub);
            }
        }
    }
    
    /**
     * This term is a "mirror" of the requested one. We will just try
     * to find variables inside it.
     */
    if (is(T_FACT) && (_value == t._value) && (_terms.size() == t._terms.size())) {
        Terms::const_iterator j = t._terms.begin();
        for (Terms::const_iterator i = _terms.begin(); i != _terms.end(); ++i) {
            if ((*i).is(T_ATOM) && (*j).is(T_VARIABLE)) {
                v.push_back((string)(*j) + " = " + (string)(*i));
            }
            ++j;
        }
    }

    if (v.size()) {
        return Term(boost::algorithm::join(v, ", ") + ".");
    }

    return Term("false.");
}

solm::Term::Term(const string& v, const solm::Term::Terms& t) : _value(v), _terms() {
    /**
     * We add all received TERMS to this, one by one. And we should
     * ignore COMMA-s, when we can go deeper inside and straight them
     * into one line.
     */
    for (Terms::const_iterator i = t.begin(); i != t.end(); ++i) {
        if ((*i).is(T_CONJUNCTOR)) {
            for (Terms::const_iterator j = (*i)._terms.begin(); j != (*i)._terms.end(); ++j) {
                _terms.push_back(*j);
            }
        } else {
            _terms.push_back(*i);
        }
    }
    
    /**
     * Now we need to clean the list of terms and remove duplicated
     * TERMs.
     */
    _terms.resize(unique(_terms.begin(), _terms.end()) - _terms.begin());
    
    /**
     * If the list has more than one element, every TRUE term should
     * be removed from the list
     */
    if (_terms.size() > 1) {
        _terms.resize(remove(_terms.begin(), _terms.end(), Term()) - _terms.begin());
    }
    
    /**
     * If it's just COMMA and there is only one argument, we should
     * simplify the term, and remove this COMMA. For example:
     * ,(alpha) => alpha or ,(king(france)) => king(france)
     */
    if (is(T_CONJUNCTOR) && (_terms.size() == 1)) {
        _value = _terms.at(0)._value;
        Terms t = _terms.at(0)._terms;
        _terms = t;
    }
}

void termerror(const char* s, ...) {
    throw string(s);
}
