<!--
 * RQDQL.com, Requirements Definition and Query Language
 *
 * Redistribution and use in source and binary forms, with or 
 * without modification, are PROHIBITED without prior written 
 * permission from the author. This product may NOT be used 
 * anywhere and on any computer except the server platform of 
 * rqdql.com. located at www.rqdql.com. If you received this 
 * code occasionally and without intent to use it, please report 
 * this incident to the author by email: team@rqdql.com
 *
 * @author Yegor Bugayenko <egor@tpc2.com>
 * @copyright Copyright (c) rqdql.com, 2010
 * @version $Id$
 *
 -->

<h1>Requirements Definition and Query Language (<b>RQDQL</b>)</h1>

    <p><a href="http://standards.ieee.org/reading/ieee/std_public/description/se/830-1998_desc.html">IEEE 830-1998</a>
        says: "SRS (<i>software requirements specification</i>) should be
        correct, unambiguous, complete, consistent, ranked for importance and/or stability,
        verifiable, modifiable, traceable". RQDQL is going to enable the creation 
        of such documents in plain text format. If you're interested to join the group
        developing RQDQL, email to <a href="mailto:team@rqdql.com">team@rqdql.com</a>.
    </p>

<h1>1. Quick Start</h1>

    <p>The scope definition document consists of <b>types</b>
        and <b>use cases</b>. For example, there are two types
        (<tt>ActorVisitor</tt> and <tt>ImageFile</tt>) and one
        use case (<tt>UC3.2</tt>) defined:</p>
    
    <p class="code">
        ActorVisitor is an "originator of HTTP request".<br/>
        UC3.2 where ActorUser (the user) deletes photos of himself:<br/>
        "we will define it later...".<br/>
        ImageFile includes: PNG content, name, and size.
    </p>
    
    <p>Everything inside double quotes is considered as an
        informal content, which we take "as is", without
        any attempt to understand what does it mean. You can double quote anything
        (except double quotes, of course), and you can place
        informal texts in any place of the document. They are ignored
        during formal analysis.</p>
    
    <p>Let's consider a bit bigger example of a type <tt>ImageFile</tt>:</p>
    
    <p class="code">
        ImageFile includes:<br/>
        &nbsp;&nbsp;PNG content: "binary content as defined by ISO-15948";<br/>
        &nbsp;&nbsp;name: "a unique alpha-numeric name of the image";<br/>
        &nbsp;&nbsp;size: "total number of bytes in PNG content".
    </p>
    
    <p>The semantic is the same &mdash; the type still contains three <b>slots</b>
        (<tt>PNG content</tt>, <tt>name</tt> and <tt>size</tt>). However
        in this example we've added an informal explanation to every one of them.
        A colon separates the name of the slot and its invariant.
        Pay attention to the dots, colons, semicolons and commas used above.
        Comma, semicolon and preposition "<tt>and</tt>" can replace each other.
        For example, the following declarations are semantically equivalent:
        </p>

    <p class="code">
        PNG content <b>and</b> name <b>and</b> size<br/>
        PNG content<b>,</b> name<b>,</b> size<br/>
        PNG content<b>;</b> name<b>;</b> size
    </p>

    <p>A slot is a type itself and can be used outside of its parent type
        by means of a preposition "<tt>of</tt>", for example:</p>

    <p class="code">
        PNG content <b>of</b> ImageFile <b>is a</b> binary file.<br/>
        Name <b>of</b> ImageFile <b>is</b> unique.<br/>
        Size <b>of</b> ImageFile <b>is a</b> "size of PNG content of this file".<br/>
    </p>
    
    <p>By means of "<tt>is/is a</tt>" we enable a declaration of <b>invariants</b>
        on types. Invariant is a <b>predicate</b>, which is always true, no matter
        what happens with the system. In the example above it is always true
        that "<tt>PNG content</tt>" is a file with binary content (not a readable
        ASCII text). Nobody can break this invariant and put a textual information
        into this slot. Similarly, the "<tt>name of ImageFile</tt>" is 
        always unique in its type. We won't be able to find two identical
        slots in the type "<tt>name of ImageFile</tt>", never.
        As you noticed, an invariant could be declared with an informal text, as we've
        done with "<tt>size of ImageFile</tt>". Such a declaration means 
        absolutely nothing and will be ignored. But it helps when you're starting
        to develop the scope document.</p>
        
    <p>In general, <b>informal texts</b> play an important role during the initial
        development of a requirements document and
        during a preliminary system analysis. When you don't know for sure
        how to define the information you have in a strict format &mdash; you
        should use informal texts. Later, when you have more information,
        you will replace them.</p>

    <p>As you've already noticed, RQDQL is a case-insensitive language in all places
        except one &mdash; type names should use
        <a href="http://en.wikipedia.org/wiki/CamelCase">CamelCase Notation</a>. Thus
        "<tt>name of ImageFile</tt>" and "<tt>Name of ImageFile</tt>" point
        us to the same type. However, <tt>ImageFile</tt> is a valid type
        name, and <tt>imagefile</tt> is just an English word.</p>

    <p>There is one special meta-type, which we should mention &mdash; Actors.
        Every type that has <tt>Actor</tt> prefix is an instance of a meta-type
        called "Actors". In the scope definition document actors represent people,
        machines, services, databases, etc. &mdash; anything and anyone
        who interacts with the <b>system under development (SUD)</b>,
        crossing the board of the SUD. Important to note that the SUD is 
        an actor itself, and its name in the document is <tt>SUD</tt>. You
        are free to use <tt>SUD</tt> or replace it with more
        convenient "<tt>we</tt>" and "<tt>us</tt>".</p>

    <p>To put things together we should declare a use case, which is 
        a step-by-step explanation of interaction between an actor
        and <b>objects</b>, for example:</p>
    
    <p class="code">
        UC8.1 where ActorUser (the user) shares ImageFile with ActorUser (the friend):<br/>
        &nbsp;&nbsp;1. The user creates ImageFile (the photo).<br/>
        &nbsp;&nbsp;2. The user updates the friend "selecting one of his contacts".<br/>
        &nbsp;&nbsp;3. We convert the photo "to the right PNG format, 600x600 maximum".<br/>
        &nbsp;&nbsp;4. We notify the friend by email.<br/>
        &nbsp;&nbsp;5. The friend reads the photo "in his own web page".<br/>
        UC8.1 0a) If "the user exceeds the maximum possible number of photos":<br/>
        &nbsp;&nbsp;1. Failure "photos limit exceeded".<br/>
        UC8.1 3a) If failed with "invalid format":<br/>
        &nbsp;&nbsp;1. "We notify user about the problem".<br/>
        &nbsp;&nbsp;2. Failure "can't convert photo".
    </p>

    <p>First line in this example is a declaration of a use case,
        which number is <tt>UC8.1</tt>. The use case has a <b>signature</b>,
        which differentiates it from all other use cases. It is not the
        ID of the use case, but the signature, which is important. This
        concept is very similar to
        <a href="http://en.wikipedia.org/wiki/Signature_(computer_science)">function signature</a>
        in programming. The 
        signature of this use case is (types are in bold):</p>

    <p class="code">
        <b>ActorUser</b> shares <b>ImageFile</b> with <b>ActorUser</b><br/>
    </p>
    
    <p>In order to include this use case into another one we should use this
        signature, filling it with particular objects. Objects start with
        article "<tt>the</tt>" and on their first occurrence they appear in round brackets. In our 
        use case there are three objects: "<tt>the user</tt>",
        "<tt>the friend</tt>" and "<tt>the photo</tt>". An object could be
        either received by a use case or created inside it. However, there is no grammar
        difference between objects received and objects created. We assume
        that an object is empty until anyone updates or creates it (more on this later).</p>
    
    <p>There are seven <b>main flows</b> in this use case, and five <b>alternative
        flows</b>. Flows <tt>1</tt>, <tt>5</tt>, <tt>6</tt>, and <tt>7</tt>
        instruct us to include other use cases that match the signatures
        provided and pass them the objects we have. Let's see
        what these flows really tell us about:</p>

    <p class="code">
        1. <b>ActorUser</b> creates <b>ImageFile</b><br/>
        &nbsp;&nbsp;the user => ActorUser<br/>
        &nbsp;&nbsp;the photo => ImageFile<br/>
        5. SUD converts <b>ImageFile</b><br/>
        &nbsp;&nbsp;the photo => ImageFile<br/>
        6. SUD notifies <b>ActorUser</b> by email.<br/>
        &nbsp;&nbsp;the user => ActorUser<br/>
        7. ActorUser reads <b>ImageFile</b>.<br/>
        &nbsp;&nbsp;the photo => ImageFile<br/>
    </p>
    
    <p>There are four use cases that our use case <tt>UC8.1</tt> includes.
        They have to be defined somewhere else in the document,
        otherwise the document would be invalid. But not all four are
        mandatory, because there is a number of <b>elementary use cases</b>,
        which are defined in the system, even if the document is
        empty. The elementary use cases are 
        (<a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> requirements pattern):</p>

    <p class="code">
        <b>Somebody</b> creates <b>something</b><br/>
        <b>Somebody</b> reads <b>something</b><br/>
        <b>Somebody</b> updates <b>something</b><br/>
        <b>Somebody</b> deletes <b>something</b><br/>
        <b>Something</b> is <b>something</b><br/>
        <b>Somebody</b> turns into <b>somebody</b><br/>
    </p>
    
    <p>As you understand, <tt>somebody</tt> means "any actor",
        and <tt>something</tt> means "object of any type".
        <tt>create</tt> means to make a new object.
        <tt>read</tt> means to read all and any slots of an object, and all their slots, etc.
        <tt>update</tt> means to change values of slots of an object.
        <tt>delete</tt> means to remove an object from a persistent storage.
        </p>
        
    <p>With <tt>turns into</tt> elementary use case we convert one
        actor to another.</p>
        
    <p>Thus, a valid flow either points us to another use case
        defined somewhere else in the document, or points us to
        an elementary use case, or points us nowhere with an informal text
        (<b>informal flow</b>).</p>

    <p>Besides that, a flow might have a special instruction, which we've seen
        in alternative flow <tt>1a1</tt> and <tt>5a2</tt>. "<tt>failure</tt>"
        means that a use case should be stopped at this point and the
        reason of this termination is explained right after the word <tt>failure</tt>
        as an informal text.</p>

    <p>Reason of failure is used by a parent use case, which included the 
        current one. This is exactly what happens in <tt>5a</tt>. We are
        waiting for a failure from "<tt>we convert the photo</tt>", and
        we're ready to accept a failure called "<tt>invalid format</tt>".
        This approach is very similar to 
        <a href="http://en.wikipedia.org/wiki/Exception_handling">exception handling paradigm</a>
        in object-oriented languages.</p>

<h1>2. Scope Ambiguity</h1>

    <p>There is only one metric that tells us everything about 
        the entire scope definition document. The metric is called 
        "<b>scope ambiguity</b>" and is calculated like:</p>
        
    <p>A = S / (S + M)</p>
    
    <p><i>S</i> stands for a total number of all informal flows,
        and <i>M</i> is a total number of CRUD-manipulators.
        Thus, if <i>A</i> equals to 0, the document is absolutely non-ambiguous,
        which is an almost impossible situation. In real world projects
        the task of a system analyst is to move <i>A</i> from 1 to 0.</p>
        
    <math xmlns="http://www.w3.org/1998/Math/MathML">
        <!-- later -->
    </math>

<h1>3. Predicates</h1>

    <p>Possible predicates now are: <tt>text</tt> and <tt>number</tt>.</p>

    <p>to be continued...</p>

<h1>4. More Details on Use Cases</h1>

    <p>This section contains a detailed review of a use cases defined
        above:</p>
        
    <p class="code">
        UC4 where ActorUser (the user) communicates:<br/>
        &nbsp;&nbsp;1. The user shares ImageFile with ActorUser.<br/>
        &nbsp;&nbsp;2. "He can do other actions, not defined yet".<br/><br/>
        UC8.1 where ActorUser (the user) shares ImageFile with ActorUser (the friend):<br/>
        &nbsp;&nbsp;1. The user creates ImageFile (the photo).<br/>
        &nbsp;&nbsp;2. The friend is friend of the user.<br/>
        &nbsp;&nbsp;3. We convert the photo "to the right PNG format, 600x600 maximum".<br/>
        &nbsp;&nbsp;4. We notify the friend by email.<br/>
        &nbsp;&nbsp;5. The friend reads the photo "in his own web page".<br/><br/>
        UC8.1 0a) If "the user exceeds the maximum possible number of photos":<br/>
        &nbsp;&nbsp;1. Failure "photos limit exceeded".<br/><br/>
        UC8.1 3a) If failed with "invalid format":<br/>
        &nbsp;&nbsp;1. "We notify user about the problem".<br/>
        &nbsp;&nbsp;2. Failure "can't convert photo".
    </p>
    
    <p><tt>UC4 where ActorUser (the user) communicates:</tt></p>
    <p style="padding-left: 5em;">
        <tt>UC4</tt> is defined with a signature "<tt>{...} communicates</tt>", which
        is unique in the scope and explicitly identifies the use case. This signature
        has only one parameter that has to be of type <tt>ActorUser</tt>.
    </p>

    <p><tt>1. The user shares ImageFile with ActorUser.</tt></p>
    <p style="padding-left: 5em;">
        First flow of the use case <tt>UC4</tt> points to another use
        case, which has to be found by signature "<tt>{...} shares {...} with {...}</tt>",
        and types of parameters are <tt>ActorUser</tt>, <tt>ImageFile</tt> and <tt>ActorUser</tt>.
        This signature matches the signature of use case <tt>UC8.1</tt>.
    </p>

    <p><tt>2. "He can do other actions, not defined yet".</tt></p>
    <p style="padding-left: 5em;">
        This flow is informal and doesn't mean anything for the RQDQL parser. It might
        mean something for the reader, but not for the software.
    </p>

    <p><tt>UC8.1 where ActorUser (the user) shares ImageFile with ActorUser (the friend):</tt></p>
    <p style="padding-left: 5em;">
        The declaration of another use case <tt>UC8.1</tt> with a signature
        "<tt>{...} shares {...} with {...}</tt>" that exactly matches the first
        flow of <tt>UC4</tt>. The use case instantiates two objects: 
        "<tt>the user</tt>" of type <tt>ActorUser</tt> and 
        "<tt>the friend</tt>" of the same type. <tt>ImageFile</tt> (the 
        second parameter of the use case) does not instantiate anything, and
        it means that <tt>UC4</tt>, which is calling <tt>UC8.1</tt>, won't be able
        to retrieve the <tt>ImageFile</tt> created/managed here.
    </p>

    <p><tt>1. The user creates ImageFile (the photo).</tt></p>
    <p style="padding-left: 5em;">
        The first flow of this use case points to an elementary use case
        "<tt>{...} creates {...}</tt>". Two parameters of this elementary
        use case have to be provided, and they are: 
        "<tt>the user</tt>" and "<tt>the photo</tt>". It is assumed that
        "<tt>the user</tt>" was instantiated before and is not <tt>NULL</tt>, and "<tt>the photo</tt>" will
        be instantiated in this elementary use case. "<tt>The photo</tt>"
        was just declared in this flow and it means that it's <tt>NULL</tt> so far.
        "<tt>The user</tt>" was passed as a parameter to this use case
        and there is no information about its status, whether it is <tt>NULL</tt> or not.
        If it is <tt>NULL</tt> (not instantiated yet) &mdash; it is an error
        and it will be found by RQDQL parser and reported.
    </p>

    <p><tt>2. The friend is one of friend of the user.</tt></p>
    <p style="padding-left: 5em;">
        Explicit instantiation of the variable happens here. "<tt>Friend of the user</tt>"
        is a slot in "<tt>the user</tt>" and 
    </p>

    <p><tt></tt></p>
    <p style="padding-left: 5em;">
    </p>

    <p><tt></tt></p>
    <p style="padding-left: 5em;">
    </p>

    <p><tt></tt></p>
    <p style="padding-left: 5em;">
    </p>

    <p><tt></tt></p>
    <p style="padding-left: 5em;">
    </p>

<h1>Appendix A. Formal Grammar</h1>

    <p>to be continued...</p>

